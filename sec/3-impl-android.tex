\subsection{Реализация приложения Android-клиента}\label{subsec:3-impl-android}\indent

\subsubsection{Описание архитектурных решений}\indent

Для реализации выбран архитектурный паттерн MVVM. Данный паттерн позволяет разделить данные, представление и бизнес-логику.

Все файлы приложения разделены по пакетам-фичам (англ. Feature).
Каждая из таких фич имеет в себе строгую иерархию классов, которая помогает следовать \hyperlink{gloss:spr}{SPR}:
\begin{enumerate}
    \item Fragment – слой View.
    Является отображением модели.
    \item ViewModel – слой ViewModel.
    Хранит в себе объект LiveData и изменяет его в зависимости от каких-либо сценариев.
    Кроме того, содержит в себе один или несколько UseCase.
    В LiveData хранится объект состояния Фрагмента.
    \item State – инкапсулирует в себе данные и состояние View (Например, Loading, DataReady и т.д.).
    \item UseCase – класс отвечающий за одно определённое действие.
    Например, получение списка всех товаров.
    В UseCase может быть внедрён один или несколько репозиториев.
    На данном уровне выполняется запуск и контроль корутин
    \item Repository – слой отвечающий за получение данных из каких-либо источников (сеть или локальная база данных в зависимости от ситуации).
    Обычно в себе содержит несколько api-классов, которые инкапсулируют в себе запросы на удалённый сервер и парсинг полученной модели и несколько dao-классов, которые инкапсулируют в себе получение данных из локальной базы данных
\end{enumerate}

Отдельными пакетами приложения являются:
\begin{itemize}
    \item Networking – содержит классы и api-интерфейсы, которые инкапсулируют в себе логику сетевых запросов
    \item Database – содержит классы, api-интерфейсы и модели данных которые инкапсулируют в себе логику запросов в базу данных
    \item CommonUtils – Небольшие утилитарные классы и функции-расширения
\end{itemize}

Для использования технологии \hyperlink{gloss:oauth}{OAuth2} реализован AuthTokenInterceptor, листинг которого можно найти в Приложении \ref{addition:android-auth-interceptor}.
Данный сервис инкапсулирует в себе логику для контроля авторизационных процессов.
Поскольку данный класс реализует в себе Interceptor интерфейс, он может быть добавлен как перехватчик к любому исходящему запросу и выполнять необходимую логику перезапроса токена, при наличии refresh\_token’а и получении 403 ошибки при выполнении запроса и добавления токенов в заголовки запроса, при их наличии.
Все токены хранятся в sharedPreferences.

На каждый из контроллеров сервера, реализованы свои api-классы.
Основная их задача заключается в выполнении запроса к серверу и возвращении данных на уровень Репозитория для дальнейшей обработки или кеширования.

Для того, чтоб не блокировать \hyperlink{gloss:ui}{UI} поток во время выполнения сетевых запросов, используются Kotlin-корутины.
Контроль за созданием и переключением контекстов корутин находится на уровнях UseCase-Repository.

Пример реализации можно найти в Приложении \ref{addition:android-request-coroutine}.

На уровне Fragment происходит подписка на изменение состояния ViewModel.
Пример реализации подписки на получаемый результат от ViewModel представлен в листинге \ref{lis:android-subscription}.

\begin{minipage}{\textwidth}
\begin{lstlisting}[language=Kotlin, captionpos=b,
    label={lis:android-subscription},
    caption={Пример реализации подписки на ViewModel}
]
productsListViewModel.model.observe(viewLifecycleOwner) {
    when (it) {
        is Loading -> onLoading()
        is NoData -> {
            onLoadingStopped()
            list_products.visibility = GONE
            text_no_data.visibility = VISIBLE
        }
        is DataReady -> {
            adapter.cleanAddAll(it.products)
            onLoadingStopped()
            text_no_data.visibility = GONE
            list_products.visibility = VISIBLE
        }
    }
}
    \end{lstlisting}
\end{minipage}

\subsubsection{Описание процесса кэширования данных}\indent

Поскольку одним из Одним из требований разрабатываемого приложения является возможность работы без подключения к интернету. 
Поэтому необходимо разработать механизм кэширования данных полученных в результате \hyperlink{gloss:http}{HTTP} запросов к серверу, 
чтобы  отображать пользователю последнюю полученную с сервера информацию.

Кэширование – один из способов оптимизации приложений.
Его суть заключается в сохранении данных, которые были получены тяжеловесной операцией из какого-либо источника, в памяти приложения/базе данных и т.д. для дальнейшего более быстрого его получения и обработки.
Кроме того, кеширование позволяет разгрузить нагрузку с сервера, поскольку к нему не будут выполняться запросы каждый раз, а только при истечении актуальности локального кэша, либо при принудительном запросе обновления данных.
В контексте мобильного приложения, кэширование позволяет создать offline режим работы приложения.
В таком случае, приложение будет иметь возможность отображать последние закэшированные данные даже без подключения к интернету.

Политики кеширования задаются полем Cache-Control общего заголовка \hyperlink{gloss:http}{HTTP}. \hyperlink{gloss:http}{HTTP} клиент OkHttp предоставляет, позволяющую автоматически котролирвать кэширование запросов.
Однако, в рамках дипломной работы, данная функция не  использована и вся логика кеширования \hyperlink{gloss:http}{HTTP} запросов выполнена самостоятельно.

Рассмотрим логику кеширования данных и проверки их актуальности.

Для этого, необходимо создать единую точку входа, через которую будут проходить все запросы клиента на загрузку данных и в случае их устаревания, разрешать выполнение запроса к серверу данных.
Таковым местом в приложении будет являеться объект HttpRequestManager.
Он будет зарегистрован в \hyperlink{gloss:di}{DI} Koin, как single, что гарантирует то, что данный объект будет являться singleton'ом.
На вход, метод HttpRequestManager\#request получает следующие параметры:
\begin{itemize}
    \item path – относительный путь, по которому надо выполнить запрос.
    \item method – \hyperlink{gloss:http}{HTTP} метод с которым будет выполнен запрос
    \item cacheControl – объект содежащий информацию о том, когда ранее загруженные данные перестанут быть актуальными.
    В случае, если этот параметр null, кеширование не будет произведено
    \item queryParams – параметры с которыми надо выполнять запрос
\end{itemize}

Для сохранения данных о том, когда в последний раз был выполнен какой-либо запрос, в локальной базе данных создана сущность RequestCache.
Эта сущность содежит в себе информацию о запросе, параметрах, методе, пути и времени, когда были выполнены все запросы, которые необходимо кешировать.
Перед любым запросом к серверу и \hyperlink{gloss:db}{БД} удаляются все неактуальные записи.
В случае, если при попытки выполнения запроса к серверу, в таблице RequestCache уже будет содержаться запись об актуальности запроса, то запрос не будет выполнен и данные будут прочитаны из БД.
Идентификация запросов выполняется по хэш-коду модели запроса.

Полный листинг HttpRequestManager класса с обработкой кэша расположен в Приложении \ref{addition:android-http-request-manager}.

\subsubsection{Описание принципов построения пользовательского интерфейса}\indent

В Android пользовательский интерфейс состоит из легко встраиваемых компонентов.
Каждый компонент может быть создан разработчиком и может управлять отображением представления на экране.
Компоненты должны быть описаны в layout.xml файле.
Вся вёрстка происходит в xml.
Программист может встраивать в layout файл как заранее определённые компоненты, так и написанные самостоятельно.
В рамках дипломной работы, полностью новые View классы не были написаны.

View – базовый компонент для всех Android компонентов.
Кроме того, есть еще ViewGroup, который является базовым для всех компонентов, обладающих возможностью хранить в себе другие компоненты.

В рамках дипломной работы, для большей части компонентов, базовым использовался ConstraintLayout.
ConstraintLayout – достаточно новый вид layout, который создан для уменьшения количества иерархий layout, что влияет на производительность.
ConstraintLayout позволяет располагать View друг относительно друга с помощью Constrains правил.

Для формирования списков в Android используются такие компоненты как ListView и RecyclerView.
Их различие заключается в том, что RecyclerView переиспользует View, которые вышли за границы экрана и не видимы пользователю, таким образом, экономя память и производительность устройства, поскольку даже для бесконечного списка, системой будет создано только то количество View, которое помещается на экран.
ListView подходит для формирования небольших списков.

Для конфигурации RecyclerView, ему необходимо передать layoutManager и adapter.

LayoutManager – класс ответственный за отображение элементов RecyclerView, за их пролистывание и размещение на экране

Adapter – класс–реализация паттерна проектирования Адаптер, является конвертером между данными и View.
К основным функциям Adapter’а относится onCreateViewHolder – создающая View для RecyclerView, onBindViewHolder – производит установку значений в созданную View.
Для создания новых View их необходимо создать из xml разметки используя LayoutInflater\#inflate.

Пример конфигурации Adapter для RecyclerView компонента можно найти в Приложении \ref{addition:android-recyclerview-adapter}.

\subsubsection{Описание использованных сторонних библиотек}\indent

Основные сторонние библиотеки, используемые в приложении:

\begin{itemize}
    \item Kotlin – стандартная библиотека Kotlin-функций;
    \item Kotlin-coroutines – поддержка Kotlin-корутин;
    \item Android Material – библиотека компонентов в MaterialDesign стиле;
    \item Navigation – для облегчения навигации между фрагментами приложения. Помогает организовать удобную навигацию в Single Activity приложении;
    \item Koin – \hyperlink{gloss:di}{DI} фремворк с поддержкой viewModel, scope и Kotlin \hyperlink{gloss:dsl}{DSL};
    \item OkHttp – библиотека инкапсулирующая логику сетевых запросов;
    \item Room – ORM для SqlLite.
\end{itemize}

\subsubsection{Сборка и структура проекта}\indent

Для разработки приложения использовался gradle – система автоматической сборки, построенная на принципах ApacheAnt и ApacheMaven, но предоставляющая \hyperlink{gloss:dsl}{DSL} на языках Groovy и Kotlin.
Был разработан для расширяемых многопроектных сборок и поддерживает инкрементальные сборки, определяя какие компоненты дерева сборки не изменились и какие задачи, зависимые от этих частей, не требуют перезапуска.

Пример структуры android-приложения представлен в листинге \ref{lis:android-structure}.

\begin{minipage}{\textwidth}
    \begin{lstlisting}[language=TypeScript, captionpos=b,
        label={lis:android-structure},
        caption={Пример структуры Android приложения}
        ]
.
|-- app
|   |-- src
|   |   |-- androidTest
|   |   |-- main
|   |   |   |-- java
|   |   |   |-- res
|   |   |   `-- AndroidManifest.xml
|   |   `-- test
|   |-- build.gradle
|   `-- proguard-rules.pro
|-- build.gradle
|-- settings.gradle
|-- gradle.properties
|-- gradlew
`-- gradlew.bat
        \end{lstlisting}            
\end{minipage}

Исходники приложения, располагаются в директории src. В папке res располагаются все ресурсы проекта (строки, переводы, layoust, anim, drawable, navigation).

Файл proguard-rules.pro содержит конфигурацию обфускации кода.
