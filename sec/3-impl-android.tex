\subsection{Реализация приложения Android-клиента}\label{subsec:3-impl-android}\indent

\subsubsection{Описание архитектурных решений}

При реализации использовался архитектурный паттерн MVV. Данный паттерн позволяет разделить данные, представление и бизнес-логику.

Все файлы приложения были разделены по пакетам-фичам (англ. Feature). Каждая из таких фич имеет в себе строгую иерархию классов, которая распределяет обязанности между классами:
\begin{enumerate}
    \item Fragment – слой View.
    Является отображением модели
    \item ViewModel – слой ViewModel.
    Хранит в себе объект LiveData и изменяет его в зависимости от каких-либо сценариев.
    Кроме того, содержит в себе один или несколько UseCase.
    В LiveData хранится объект состояния Фрагмента
    \item State – инкапсулирует в себе данные и состояние View (Например, Loading, DataReady и т.д.)
    \item UseCase – класс отвечающий за одно определённое действие.
    Например, получение списка всех товаров.
    В UseCase может быть внедрён один или несколько репозиториев.
    На данном уровне выполняется запуск и контроль корутин
    \item Repository – слой отвечающий за получение данных из каких-либо источников (сеть или локальная база данных в зависимости от ситуации).
    Обычно в себе содержит несколько api-классов, которые инкапсулируют в себе запросы на удалённый сервер и парсинг полученной модели и несколько dao-классов, которые инкапсулируют в себе получение данных из локальной базы данных
\end{enumerate}

Отдельными пакетами приложения являются:
\begin{itemize}
    \item Networking – содержит классы и api-интерфейсы, которые инкапсулируют в себе логику сетевых запросов
    \item Database - содержит классы, api-интерфейсы и модели данных которые инкапсулируют в себе логику запросов в базу данных
    \item CommonUtils – Небольшие утилитарные классы и функции-расширения
\end{itemize}

\subsubsection{Описание архитектурных решений}\indent
\TODO{Проверить название секции}

Поскольку в приложении используется аутентификация на сервере по технологии OAuth2, должна быть реализована логика, которая может быть легко встраиваема в любой компонент при помощи Dependency Injection, кроме того, должны быть механизмы перезапроса access\_token’а, при наличии refresh\_token’а, в случае истечения срока его действия.
Для был реализован RefreshTokenUsecase, листинг которого можно найти в Приложении 1.
Данный сервис инкапсулирует в себе логику для контроля авторизационных процессов.
Поскольку данный класс реализует в себе Interceptor интерфейс, он может быть добавлен как перехватчик к любому исходящему запросу и выполнять необходимую логику перезапроса токена, при наличии refresh\_token’а и получении 403 ошибки при выполнении запроса и добавления токенов в заголовки запроса, при их наличии.
Все токены хранятся в sharedPreferences.

CartService занимается контролем за состоянием корзины, а также её управлением.

На каждый из контроллеров сервера, реализованы свои api-классы.
Основная их задача заключается в выполнении запроса к серверу и возвращение данных на уровень Репозитория для дальнейшей обработки или кеширования.

Для того, чтоб не блокировать UI поток во время выполнения сетевых запросов, используются Kotlin-корутины.
Контроль за созданием и переключением контекстов корутин находится на уровнях UseCase-Repository.

\TODO{Ссылка на приложение}
Пример реализации можно найти в Приложении 2

На уровне Fragment происходит подписка на изменение состояния ViewModel.
Пример реализации подписки на получаемый результат от ViewModel представлен на листинге \ref{lis:android-subscription}.

\begin{lstlisting}[language=Kotlin, captionpos=b,
label={lis:android-subscription},
caption={Пример реализации подписки на ViewModel}
]
productsListViewModel.model.observe(viewLifecycleOwner) {
    when (it) {
        is Loading -> onLoading()
        is NoData -> {
            onLoadingStopped()
            list_products.visibility = GONE
            text_no_data.visibility = VISIBLE
        }
        is DataReady -> {
            adapter.cleanAddAll(it.products)
            onLoadingStopped()
            text_no_data.visibility = GONE
            list_products.visibility = VISIBLE
        }
    }
}
\end{lstlisting}

\subsubsection{Описание архитектурных решений}\indent
\TODO{Проверить название секции}

В Android пользовательский интерфейс состоит из легко встраиваемых компонентов.
Каждый компонент может быть создан разработчиком и может управлять отображением представления на экране.
Компоненты должны быть описаны в layout.xml файле.
Вся вёрстка происходит в xml.
Программист может встраивать в layout файл как заранее определённые компоненты, так и написанные самостоятельно.
В рамках курсовой работы, полностью новые View классы не были написаны.

View – базовый компонент для всех Android компонентов.
Кроме того, есть еще ViewGroup, который является базовым для всех компонентов, обладающих возможностью хранить в себе другие компоненты.

В рамках курсовой работы, для большей части компонентов, базовым использовался ConstraintLayout.
ConstraintLayout – достаточно новый вид layout, который создан для уменьшения кол-ва иерархий layout, что влияет на производительность.
ConstraintLayout позволяет располагать View друг относительно друга с помощью Constrains правил.

Для формирования списков в Android используются такие компоненты как ListView и RecyclerView.
Их различие заключается в том, что RecyclerView переиспользует View, которые вышли за границы экрана и не видимы пользователю, таким образом, экономя память и производительность устройства, поскольку даже для бесконечного списка, системой будет создано только то кол-во View, которое помещается на экран.
ListView подходит для формирования небольших списков.

Для конфигурации RecyclerView, ему необходимо передать layoutManager и adapter.

LayoutManager – класс ответственный за отображение элементов RecyclerView, за их пролистывание и размещение на экране

Adapter – класс –реализация паттерна проектирования Адаптер, является конвертером между данными и View.
К основным функциям Adapter’а относится onCreateViewHolder – создающая View для RecyclerView, onBindViewHolder – производит установку значений в созданную View.
Для создания новых View их необходимо создать из xml разметки используя LayoutInflater\#inflate.
\TODO{Ссылка на приложение}
Пример конфигурации Adapter для RecyclerView компонента можно найти в Приложении 3.

\subsubsection{Описание использованных сторонних библиотек}\indent
Все зависимости используемые в проекте указаны в build.gradle файле приложения, который представлен в приложении.

Основные сторонние библиотеки, используемые в приложении:
\begin{itemize}
    \item Kotlin – стандартная библиотека Kotlin-функций
    \item Kotlin-coroutines – поддержка Kotlin-корутин
    \item Android Material – библиотека компонентов в MaterialDesign стиле
    \item Navigation – для облегчения навигации между фрагментами приложения. Помогает организовать удобную навигацию в Single Activity приложении.
    \item Koin – DI фремворк с поддержкой viewModel, scope и KotlinDSL
    \item Retrofit2 – библиотека инкапсулирующая логику сетевых запросов
    \item Room – ORM для SqlLite
\end{itemize}

\subsubsection{Сборка и структура проекта}\indent
Для разработки приложения использовался gradle – система автоматической сборки, построенная на принципах ApacheAnt и ApacheMaven, но предоставляющая DSL на языках Groovy и Kotlin.
Был разработан для расширяемых многопроектных сборок и поддерживает инкрементальные сборки, определяя какие компоненты дерева сборки не изменились и какие задачи, зависимые от этих частей, не требуют перезапуска.

Пример структуры android-приложения представлен на листинге \ref{lis:android-structure}

\begin{lstlisting}[language=TypeScript, captionpos=b,
label={lis:android-structure},
caption={Пример структуры Android приложения}
]
.
|-- app
|   |-- src
|   |   |-- androidTest
|   |   |-- main
|   |   |   |-- java
|   |   |   |-- res
|   |   |   `-- AndroidManifest.xml
|   |   `-- test
|   |-- build.gradle
|   `-- proguard-rules.pro
|-- build.gradle
|-- settings.gradle
|-- gradle.properties
|-- gradlew
`-- gradlew.bat
\end{lstlisting}

Исходники приложения, как правило, располагаются в директории src. В папке res располагаются все ресурсы проекта (строки, переводы, layoust, anim, drawable, navigation).

Файл proguard-rules.pro содержит конфигурацию обфускации кода.
