\subsection{Реализация приложения Android-клиента}\label{subsec:3-impl-android}\indent

\subsubsection{Описание архитектурных решений}\indent

При реализации использовался архитектурный паттерн MVVM. Данный паттерн позволяет разделить данные, представление и бизнес-логику.

Все файлы приложения были разделены по пакетам-фичам (англ. Feature).
Каждая из таких фич имеет в себе строгую иерархию классов, которая помогает следовать Single Responsibility принципу:
\begin{enumerate}
    \item Fragment – слой View.
    Является отображением модели
    \item ViewModel – слой ViewModel.
    Хранит в себе объект LiveData и изменяет его в зависимости от каких-либо сценариев.
    Кроме того, содержит в себе один или несколько UseCase.
    В LiveData хранится объект состояния Фрагмента
    \item State – инкапсулирует в себе данные и состояние View (Например, Loading, DataReady и т.д.)
    \item UseCase – класс отвечающий за одно определённое действие.
    Например, получение списка всех товаров.
    В UseCase может быть внедрён один или несколько репозиториев.
    На данном уровне выполняется запуск и контроль корутин
    \item Repository – слой отвечающий за получение данных из каких-либо источников (сеть или локальная база данных в зависимости от ситуации).
    Обычно в себе содержит несколько api-классов, которые инкапсулируют в себе запросы на удалённый сервер и парсинг полученной модели и несколько dao-классов, которые инкапсулируют в себе получение данных из локальной базы данных
\end{enumerate}

Отдельными пакетами приложения являются:
\begin{itemize}
    \item Networking – содержит классы и api-интерфейсы, которые инкапсулируют в себе логику сетевых запросов
    \item Database - содержит классы, api-интерфейсы и модели данных которые инкапсулируют в себе логику запросов в базу данных
    \item CommonUtils – Небольшие утилитарные классы и функции-расширения
\end{itemize}

Поскольку в приложении используется аутентификация на сервере по технологии OAuth2, должна быть реализована логика, которая может быть легко встраиваема в любой компонент при помощи Dependency Injection, кроме того, должны быть механизмы перезапроса access\_token’а, при наличии refresh\_token’а, в случае истечения срока его действия.
Для был реализован AuthTokenInterceptor, листинг которого можно найти в Приложении \ref{addition:android-auth-interceptor}.
Данный сервис инкапсулирует в себе логику для контроля авторизационных процессов.
Поскольку данный класс реализует в себе Interceptor интерфейс, он может быть добавлен как перехватчик к любому исходящему запросу и выполнять необходимую логику перезапроса токена, при наличии refresh\_token’а и получении 403 ошибки при выполнении запроса и добавления токенов в заголовки запроса, при их наличии.
Все токены хранятся в sharedPreferences.

На каждый из контроллеров сервера, реализованы свои api-классы.
Основная их задача заключается в выполнении запроса к серверу и возвращение данных на уровень Репозитория для дальнейшей обработки или кеширования.

Для того, чтоб не блокировать UI поток во время выполнения сетевых запросов, используются Kotlin-корутины.
Контроль за созданием и переключением контекстов корутин находится на уровнях UseCase-Repository.

Пример реализации можно найти в Приложении \ref{addition:android-request-coroutine}

На уровне Fragment происходит подписка на изменение состояния ViewModel.
Пример реализации подписки на получаемый результат от ViewModel представлен на листинге \ref{lis:android-subscription}.

\begin{lstlisting}[language=Kotlin, captionpos=b,
label={lis:android-subscription},
caption={Пример реализации подписки на ViewModel}
]
productsListViewModel.model.observe(viewLifecycleOwner) {
    when (it) {
        is Loading -> onLoading()
        is NoData -> {
            onLoadingStopped()
            list_products.visibility = GONE
            text_no_data.visibility = VISIBLE
        }
        is DataReady -> {
            adapter.cleanAddAll(it.products)
            onLoadingStopped()
            text_no_data.visibility = GONE
            list_products.visibility = VISIBLE
        }
    }
}
\end{lstlisting}

\subsubsection{Описание процесса кэширования данных}\indent

Поскольку одним из требований разрабатываемого приложения является возможность работы без подключения к интернету, отображая последнюю полученную с сервера информацию, необходимо разработать механизм кэширования данных полученных вследствии Http запросов к серверу.

Кэширование - один из способов оптимизации приложений.
Его суть заключается в сохранении данных, которые были получена тяжеловесной операцией из какого-либо источника, в пямяти приложения/базе данных и т.д. для дальнейшего более быстрого его получения и обработки.
Кроме того, кеширование позволяет разгрузить нагрузку с сервера, поскольку к нему не будут выполняться запросы каждый раз, а только при истечении актуальности локального кэша, либо при принудительном запросе обновления данных.
В контексте мобильного приложения, кэширование позволяет создать offline режим работы приложения.
В таком случае, приложение будет иметь возможность отображать последние закэшированные данные даже без подключения к интернету.

Политики кеширования задаются полем Cache-Control общего заголовка HTTP. Http клиент OkHttp предоставляет, позволяющую автоматически котролирвать кэширование запросов.
Однако, в рамках дипломной работы, данная функция не будет использована и вся логика кеширования HTTP запросов будет выполнена самостоятельно.

Рассмотрим логику кеширования данных и проверки их актуальности.
\TODO{Интерцепторы, если успею}
Для этого, необходимо создать одно место, через которое будет проходить все попытки клиента загрузить данные и в случае их устаревания, разрешать выполнение запроса к серверу данных.
Таковым местом в приложении будет являеться объект HttpRequestManager.
Он будет зарегистрован в DI Koin, как single, что гарантирует то, что данный объект будет являться singleton'ом.
На вход, метод HttpRequestManager\#request
\begin{itemize}
    \item path - относительный путь, по которому надо выполнить запрос
    \item method - HTTP метод с которым будет выполнен запрос
    \item cacheControl - объект содежащий информацию о том, когда ранее загруженные данные перестанут быть актуальными.
    В случае, если этот параметр null, кеширование не будет произведено
    \item queryParams - параметры с которыми надо выполнять запрос
\end{itemize}

Для сохранения данных о том, когда в последний раз был выполнен какой-либо запрос, в локальной базе данных создана сущность RequestCache.
Которая содежит в себе информацию о запросе, параметрах, методе, пути и времени, когда были выполнены все запросы, которые необходимо кешировать.
Перед любым запросом к серверу и базы данных удаляются все неактуальные записи.
В случае, если при попытки выполнения запроса к серверу, в таблице RequestCache уже будет содержаться запись об актуальности запроса, то запрос не будет выполнен и данные будут прочитаны из БД.
Идентификация запросов выполняется по хэш-коду модели запроса.

Полный листинг HttpRequestManager класса с обработкой кэша расположен в Приложении \ref{addition:android-http-request-manager}

\subsubsection{Описание принципов построения пользовательского интерфейса}\indent

В Android пользовательский интерфейс состоит из легко встраиваемых компонентов.
Каждый компонент может быть создан разработчиком и может управлять отображением представления на экране.
Компоненты должны быть описаны в layout.xml файле.
Вся вёрстка происходит в xml.
Программист может встраивать в layout файл как заранее определённые компоненты, так и написанные самостоятельно.
В рамках курсовой работы, полностью новые View классы не были написаны.

View – базовый компонент для всех Android компонентов.
Кроме того, есть еще ViewGroup, который является базовым для всех компонентов, обладающих возможностью хранить в себе другие компоненты.

В рамках курсовой работы, для большей части компонентов, базовым использовался ConstraintLayout.
ConstraintLayout – достаточно новый вид layout, который создан для уменьшения кол-ва иерархий layout, что влияет на производительность.
ConstraintLayout позволяет располагать View друг относительно друга с помощью Constrains правил.

Для формирования списков в Android используются такие компоненты как ListView и RecyclerView.
Их различие заключается в том, что RecyclerView переиспользует View, которые вышли за границы экрана и не видимы пользователю, таким образом, экономя память и производительность устройства, поскольку даже для бесконечного списка, системой будет создано только то кол-во View, которое помещается на экран.
ListView подходит для формирования небольших списков.

Для конфигурации RecyclerView, ему необходимо передать layoutManager и adapter.

LayoutManager – класс ответственный за отображение элементов RecyclerView, за их пролистывание и размещение на экране

Adapter – класс –реализация паттерна проектирования Адаптер, является конвертером между данными и View.
К основным функциям Adapter’а относится onCreateViewHolder – создающая View для RecyclerView, onBindViewHolder – производит установку значений в созданную View.
Для создания новых View их необходимо создать из xml разметки используя LayoutInflater\#inflate.

Пример конфигурации Adapter для RecyclerView компонента можно найти в Приложении \ref{addition:android-recyclerview-adapter}.

\subsubsection{Описание использованных сторонних библиотек}\indent
Все зависимости используемые в проекте указаны в build.gradle файле приложения, который представлен в приложении.

Основные сторонние библиотеки, используемые в приложении:
\begin{itemize}
    \item Kotlin – стандартная библиотека Kotlin-функций
    \item Kotlin-coroutines – поддержка Kotlin-корутин
    \item Android Material – библиотека компонентов в MaterialDesign стиле
    \item Navigation – для облегчения навигации между фрагментами приложения. Помогает организовать удобную навигацию в Single Activity приложении.
    \item Koin – DI фремворк с поддержкой viewModel, scope и KotlinDSL
    \item Retrofit2 – библиотека инкапсулирующая логику сетевых запросов
    \item Room – ORM для SqlLite
\end{itemize}

\subsubsection{Сборка и структура проекта}\indent
Для разработки приложения использовался gradle – система автоматической сборки, построенная на принципах ApacheAnt и ApacheMaven, но предоставляющая DSL на языках Groovy и Kotlin.
Был разработан для расширяемых многопроектных сборок и поддерживает инкрементальные сборки, определяя какие компоненты дерева сборки не изменились и какие задачи, зависимые от этих частей, не требуют перезапуска.

Пример структуры android-приложения представлен на листинге \ref{lis:android-structure}

\begin{lstlisting}[language=TypeScript, captionpos=b,
label={lis:android-structure},
caption={Пример структуры Android приложения}
]
.
|-- app
|   |-- src
|   |   |-- androidTest
|   |   |-- main
|   |   |   |-- java
|   |   |   |-- res
|   |   |   `-- AndroidManifest.xml
|   |   `-- test
|   |-- build.gradle
|   `-- proguard-rules.pro
|-- build.gradle
|-- settings.gradle
|-- gradle.properties
|-- gradlew
`-- gradlew.bat
\end{lstlisting}

Исходники приложения, как правило, располагаются в директории src. В папке res располагаются все ресурсы проекта (строки, переводы, layoust, anim, drawable, navigation).

Файл proguard-rules.pro содержит конфигурацию обфускации кода.
