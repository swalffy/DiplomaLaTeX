\subsection{Реализация приложения REST-сервера}\label{subsec:3-impl-server}\indent

\subsubsection{Описание архитектурных решений}\indent

При реализации использовался архитектурный паттерн MVC. Данный паттерн позволяет разделить данные, представление и бизнес-логику.

Все классы были разделены на 3 слоя:
\begin{enumerate}
    \item Данные – в этот слой входят все классы из пакетов model и repository
    \item Сервис – в этот слоя входят классы из пакета service.
    На этом уровне выполняется основная бизнес-логика приложения.
    Сервис существует для каждой значимой сущности и абстрагирован от других сущностей.
    \item Контроллер – в этот слой входят классы из пакета controller.
    На данном слое происходит обработка ошибок и формирования ответов клиенту.
    На данном слое происходит json-сериализация с помощью встроенного в Spring-framework сериализатора Jackson.
    Для получения/отправки данных используется шаблон проектирования DTO (Data Transfer Object).
\end{enumerate}
Отдельными модулями приложения являются пакеты:

\begin{enumerate}
    \item Utils – пакет в котором хранятся общие утилиты, необходимые приложению, а также поддерживаемые Kotlin-ом расширяющие функции
    \item Config – пакет в котором производится конфигурация Spring фреймворка.
    А также создаваемые для Spring DI – компоненты. Примеры конфигурации бинов будут приведены в приложении
\end{enumerate}

\subsubsection{Описание основных аннотаций}\indent

Для маппинга Kotlin data классов используемых в БД используются JPA Persistence API аннотации.

@Entity – используется для сообщения Spring о том, что класс является сущностью используемой в БД.

Т.к. для каждого класса, используемого в БД необходим, конструктор по умолчанию (без параметров), а kotlin-data классы не поддерживают его, в приложении используется kotlin-noarg gradle плагин, который генерирует конструктор по умолчанию для всех data классов.

@Table – используется для указания имени таблицы, которое будет использовано при обращении.

@get: - является решением, для того чтоб размещать аннотации над соответствующим геттером(т.к. в Kotlin геттеры не пишутся и генерируются автоматически).

@Column – используется для указания имени, а также некоторого списка характеристик колонки таблицы (например nullable) определённого поля класса.

Если в классе есть поля объектного типа, то должна быть указана связь между таблицами (@OneToMany, @ManyToOne, @ManyToMany), а так же аннотация для указания, по какому полю производить связь (@JoinColumn).

@Controller, @RestController, @Service, @Repository – используются для указания Spring о том, к какому типу компонента относится тот или иной класс.

@Bean – сообщает Spring о том, что объект является Spring-Bean.

@Autowired – сообщает Spring о том, что реализацию данного поля нужно найти среди Spring-Beanов.

@Configuration – указывает на то, что класс является конфигурационным.

Связка @JsonManagedReferense/@JsonBackReference является аннотациями Jackson-сериализатора и служат для того, чтоб избежать рекурсивной десериализации объектов, которые ссылаются друг на друга.

@JsonIgnore – служит для того, чтоб указать Jackson-сериализатору то, что данное поле следует игнорировать пре сериализации.

@GetMapping, @PostMapping, @PutMapping, @DeleteMapping, @RequestMapping – аннотации сообщающие диспатчеру о том, по какому url адресу, данный метод должен обрабатывать запросы.

\subsubsection{Описание процесса авторизации}\indent

Для контроля доступа и возможности назначения персональных скидок, в системе реализована возможность авторизации. Авторизация происходит по протоколуOAuth2

OAuth – открытый протокол авторизации, который позволяет предоставить третьей стороне ограниченный доступ к защищенным ресурсам пользователя без необходимости передавать ей логин и пароль.

Преимущества OAuth2:
\begin{itemize}
    \item Клиент может быть уверен в том, что несанкционированный доступ к его личным данным невозможен.
    Не владея логином и паролем пользователя, приложение может выполнять только ограниченный ряд действий
    \item Не нужно заботиться об обеспечении конфиденциальности логина и пароля.
    Т.к. логин и пароль не передаются приложению и как следствие, не могут попасть в руки злоумышленников
\end{itemize}

Результатом авторизации является получение access token – некий ключ (хешированая строка) предъявление которого является доступом к защищенным ресурсам.
Самым простым способом передачи является его указание в заголовках вместе с запросом.

\subsubsection{Описание работы почтового клиента с генерацией шаблонов}\indent

Для отправки e-mail сообщений используется Java-класс JavaMailSender, который сконфигурирован как Spring Bean и доступен для Dependecy Injection.
Для конфигурации данного класса ему передаются список параметов (как например логий и пароль от SMTP сервера, который будет рассылать сообщения)

На текущий момент сообщения отправляются при оформлении заказа.
Т.е. когда приходит запрос на регистрацию заказа, заказ сначала добавляется в БД, в случае успешного добавления, из базы данных получается необходимый шаблон почтового сообщения, в который вставляются данные заказа.
Для вставки корректных данных, в шаблоне предусмотрены специальные метки заданные регулярным выражением: "<\textbackslash\textbackslash[([\textasciicircum\textbackslash\textbackslash]\%]*)\textbackslash\textbackslash]>"

\subsubsection{Unit-тестирование}\indent

Unit-тестирование – процесс позволяющий проверить на корректность отдельные модули исходного кода программы, с соответсвующиеми управляющими данными, процедурами использования и обработки. Идея заключается в том, чтобы писать тесты для каждой нетривиальной функции или метода. Это позволяет достаточно быстро проверить работоспособность кода и не привело ли изменение к регрессии.

Для упрощения написания тестов, в приложении используются библиотеки Mockk и AssertJ.

Mockk – это простая Kotlin библиотека для создания объектов заглушек, которые не несут в себе никакой логики, однако используются для симуляции поведения объектов с определёнными условиями. Т.к. эта библиотека работает по приципу наследования от мокируемого объекта, а в Kotlin все классы являются по умолчанию ненаследуемыми, необходимо использовать allopen graddle плагин, который делает все классы открытыми по умолчанию.

AssertJ – библиотека, которая предоставляет удобный интерфейс для написания тестовых сравнений и главной целью ставит улучшение читаемости тестового кода, а также повышения удобности отладки тестов.

В текущей системе, тестами покрыты все нетривиальные методы Сервис-слоя, а также сериализаторы и парсер почтовых сообщений.


\subsubsection{Сборка проекта}\indent

Для сборки проекта используется система автоматической сборки Gradlle.

Данный сборщик поддерживает написание build-скриптов на языке Kotlin, Groovy. Имеется возможность тонкой настройки скриптов сборки, а также дополнительных задач, которые будут выполнены перед сборкой.

Кроме того, есть возможность скачивания зависимостей из maven-repository сервисов и поддержка плагинов (в данном приложении, например были использованы плагины allopen и noargconstr, для обеспечения совместимости языка Kotlin с некоторыми библиотеками или фреймворками. Также, поддержка инкрементальной сборки и отслеживание изменённого кода, может значительно сократить время сборки (особенно это видно на больших проектах).
